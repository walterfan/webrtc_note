<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Transport-wide Congestion Control &mdash; webrtc_tutorial 1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Congeston Control Evaluation" href="webrtc_cc_evaluation.html" />
    <link rel="prev" title="Google REMB" href="webrtc_remb.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> webrtc_tutorial
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../0.tutorial/index.html">0. WebRTC 简明教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1.basic/index.html">1. WebRTC 基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2.transport/index.html">2. WebRTC 传输</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">3. WebRTC 媒体</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="overview.html">WebRTC 媒体概论</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_audio.html">WebRTC 音频</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_video.html">WebRTC 视频</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="webrtc_qos.html">WebRTC QoS</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="webrtc_cc.html">WebRTC 拥塞控制</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="webrtc_gcc.html">Google Congestion Control v1</a></li>
<li class="toctree-l4"><a class="reference internal" href="webrtc_remb.html">Google REMB</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Transport-wide Congestion Control</a></li>
<li class="toctree-l4"><a class="reference internal" href="webrtc_cc_evaluation.html">Congeston Control Evaluation</a></li>
<li class="toctree-l4"><a class="reference internal" href="webrtc_cc.html#id3">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="webrtc_cc.html#id6">基本架构</a></li>
<li class="toctree-l4"><a class="reference internal" href="webrtc_cc.html#id7">术语</a></li>
<li class="toctree-l4"><a class="reference internal" href="webrtc_cc.html#id8">交互式实时媒体的拥塞控制的需求</a></li>
<li class="toctree-l4"><a class="reference internal" href="webrtc_cc.html#id11">标准化组织及其发布的文档</a></li>
<li class="toctree-l4"><a class="reference internal" href="webrtc_cc.html#id12">标准化状况和存在的问题</a></li>
<li class="toctree-l4"><a class="reference internal" href="webrtc_cc.html#id17">常用方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="webrtc_cc.html#id18">拥塞控制算法</a></li>
<li class="toctree-l4"><a class="reference internal" href="webrtc_cc.html#id22">对于拥塞控制算法的评估和验证</a></li>
<li class="toctree-l4"><a class="reference internal" href="webrtc_cc.html#id25">参考资料</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_fec.html">WebRTC FEC</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_rtx.html">WebRTC RTX</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_metrics.html">WebRTC Metrics</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_e2e_delay.html">WebRTC E2E Delay</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_qos.html#id3">概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_qos.html#id4">流畅与清晰的平衡</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_qos.html#metrics">Metrics</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_qos.html#glossary">Glossary</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_qos.html#id8">测试工具</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_qos.html#id9">实例</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_qos.html#faq">FAQ</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_qos.html#id14">参考资料</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="reference internal" href="webrtc_cc.html">WebRTC 拥塞控制</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="webrtc_gcc.html">Google Congestion Control v1</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_remb.html">Google REMB</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Transport-wide Congestion Control</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">扩展</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transport-wide-sequence-number">Transport-wide Sequence Number</a></li>
<li class="toctree-l4"><a class="reference internal" href="#transport-wide-rtcp-feedback-message">Transport-wide RTCP Feedback Message</a></li>
<li class="toctree-l4"><a class="reference internal" href="#receive-delta">Receive Delta</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">基于延迟的发送端拥塞控制</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">其他算法细节</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">参考资料</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_cc_evaluation.html">Congeston Control Evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_cc.html#id3">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_cc.html#id6">基本架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_cc.html#id7">术语</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_cc.html#id8">交互式实时媒体的拥塞控制的需求</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_cc.html#id11">标准化组织及其发布的文档</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_cc.html#id12">标准化状况和存在的问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_cc.html#id17">常用方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_cc.html#id18">拥塞控制算法</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_cc.html#id22">对于拥塞控制算法的评估和验证</a></li>
<li class="toctree-l3"><a class="reference internal" href="webrtc_cc.html#id25">参考资料</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_fec.html">WebRTC FEC</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_rtx.html">WebRTC RTX</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_red.html">WebRTC RED</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_temporal_scalability.html">Temporal scalability</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_feedback.html">WebRTC Feedback</a></li>
<li class="toctree-l2"><a class="reference internal" href="jitter_buffer.html">Jitter Buffer</a></li>
<li class="toctree-l2"><a class="reference internal" href="insertable_stream.html">Insertable Stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="web_codec.html">Web Codecs</a></li>
<li class="toctree-l2"><a class="reference internal" href="web_transport.html">Web Transport</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_svc.html">WebRTC SVC</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_metrics.html">WebRTC Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_e2e_delay.html">WebRTC E2E Delay</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_simulcast.html">WebRTC Simulcast</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4.practice/index.html">4. WebRTC 实践</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5.code/index.html">5. WebRTC 源码分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6.tool/index.html">5. WebRTC 工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../7.misc/index.html">6. WebRTC 关联技术</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">webrtc_tutorial</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">3. WebRTC 媒体</a> &raquo;</li>
          <li><a href="webrtc_qos.html">WebRTC QoS</a> &raquo;</li>
          <li><a href="webrtc_cc.html">WebRTC 拥塞控制</a> &raquo;</li>
      <li>Transport-wide Congestion Control</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/3.media/webrtc_twcc.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="transport-wide-congestion-control">
<h1>Transport-wide Congestion Control<a class="headerlink" href="#transport-wide-congestion-control" title="Permalink to this headline">¶</a></h1>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 81%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Abstract</strong></p></td>
<td><p>RTP Extensions for Transport-wide Congestion Control</p></td>
</tr>
<tr class="row-even"><td><p><strong>Authors</strong></p></td>
<td><p>Walter Fan</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Status</strong></p></td>
<td><p>WIP</p></td>
</tr>
<tr class="row-even"><td><p><strong>Updated</strong></p></td>
<td><p>2023-05-14</p></td>
</tr>
</tbody>
</table>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#id3" id="id14">概述</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id15">扩展</a></p></li>
<li><p><a class="reference internal" href="#transport-wide-sequence-number" id="id16">Transport-wide Sequence Number</a></p></li>
<li><p><a class="reference internal" href="#transport-wide-rtcp-feedback-message" id="id17">Transport-wide RTCP Feedback Message</a></p>
<ul>
<li><p><a class="reference internal" href="#rtp-packet-status" id="id18">Rtp Packet Status</a></p></li>
<li><p><a class="reference internal" href="#packet-chunk" id="id19">Packet chunk</a></p>
<ul>
<li><p><a class="reference internal" href="#run-length-chunk" id="id20">Run Length Chunk</a></p></li>
<li><p><a class="reference internal" href="#status-vector-chunk" id="id21">Status Vector Chunk</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#receive-delta" id="id22">Receive Delta</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id23">基于延迟的发送端拥塞控制</a></p>
<ul>
<li><p><a class="reference internal" href="#id6" id="id24">基本方法</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id7" id="id25">其他算法细节</a></p>
<ul>
<li><p><a class="reference internal" href="#id8" id="id26">动态阈值的生成</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id27">指数平滑算法和最小二乘法</a></p>
<ul>
<li><p><a class="reference internal" href="#ewma-exponentially-weighted-moving-average" id="id28">EWMA（Exponentially Weighted Moving Average ）</a></p></li>
<li><p><a class="reference internal" href="#least-squars-method" id="id29">最小二乘法(Least Squars Method)</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#id11" id="id30">参考资料</a></p></li>
</ul>
</div>
<section id="id3">
<h2><a class="toc-backref" href="#id14">概述</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>TWCC 属于 GCC(Google Congestion Control ) 的第二版， 相对于第一版，它做了如下改进</p>
<ol class="arabic simple">
<li><p>接收端只做反馈，所有的探测和估算逻辑都放在发送端</p></li>
<li><p>将第一版中使用的 Kalman Filter 改为 Trendline Filter</p></li>
<li><p>带宽估算中综合考虑带宽探测的码率，确认收到的流量码率，基于丢包和基于延迟所估算的码率</p></li>
</ol>
<p>这样做的好处在于</p>
<ol class="arabic simple">
<li><p>The congestion control algorithms are easier to maintain and improve as there is less synchronization between sender and receiver versions needed.</p></li>
</ol>
<p>2) More flexibility in what algorithms are used, as long as they are having most of their logic on the send-side.
For instance different behavior can be used depending on if the rate produced  is application limited or not.</p>
<ol class="arabic simple" start="3">
<li><p>It is a better fit for congestion control as the congestion controller doesn’t operate on media streams, but on packet flows.</p></li>
<li><p>It allows for earlier packet loss detection (and recovery) since a loss in stream A can be detected when a packet from stream B is received, thus we don’t have to wait until the next packet of stream A is received.</p></li>
</ol>
<p>Inter-packet delay variation: d(i) = A(i) - S(i) - (A(i-1) - S(i-1))</p>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id15">扩展</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>Transport wide sequence numbers header extension
在 RTP 包中添加一个扩展头，放置传输层面的序号</p></li>
</ol>
<p>SDP</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">=</span><span class="n">extmap</span><span class="p">:</span><span class="mi">5</span> <span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">ietf</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="nb">id</span><span class="o">/</span><span class="n">draft</span><span class="o">-</span><span class="n">holmer</span><span class="o">-</span><span class="n">rmcat</span><span class="o">-</span><span class="n">transport</span><span class="o">-</span><span class="n">wide</span><span class="o">-</span><span class="n">cc</span><span class="o">-</span><span class="n">extensions</span><span class="o">-</span><span class="mi">01</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Transport Feedback
增加一个 RTCP 反馈消息，用来反馈接收到的数据包及其延迟的信息 RTCP-Transport-FB 默认发送频率 1time/100ms，同时其动态适应使用 5％的可用带宽，最大频率值为 1time/50ms、最小频率值为 1time/250ms。以 1time/100ms 的频率发送，其最大需要耗费 16kbps 带宽</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="o">=</span><span class="n">rtcp</span><span class="o">-</span><span class="n">fb</span><span class="p">:</span><span class="mi">100</span> <span class="n">transport</span><span class="o">-</span><span class="n">cc</span>
</pre></div>
</div>
</section>
<section id="transport-wide-sequence-number">
<h2><a class="toc-backref" href="#id16">Transport-wide Sequence Number</a><a class="headerlink" href="#transport-wide-sequence-number" title="Permalink to this headline">¶</a></h2>
<p>在每个要发送的 RTP 包中添加一个扩展头，包含 16 bits 的序号 sequence number.  在同一个传输通道中，每发一个 RTP 包，这个序号就加一</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">0</span>                   <span class="mi">1</span>                   <span class="mi">2</span>                   <span class="mi">3</span>
 <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">0</span> <span class="mi">1</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="o">|</span>       <span class="mh">0xBE</span>    <span class="o">|</span>    <span class="mh">0xDE</span>       <span class="o">|</span>           <span class="n">length</span><span class="o">=</span><span class="mi">1</span>            <span class="o">|</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="o">|</span>  <span class="n">ID</span>   <span class="o">|</span> <span class="n">L</span><span class="o">=</span><span class="mi">1</span>   <span class="o">|</span><span class="n">transport</span><span class="o">-</span><span class="n">wide</span> <span class="n">sequence</span> <span class="n">number</span> <span class="o">|</span> <span class="n">zero</span> <span class="n">padding</span>  <span class="o">|</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
</pre></div>
</div>
</section>
<section id="transport-wide-rtcp-feedback-message">
<h2><a class="toc-backref" href="#id17">Transport-wide RTCP Feedback Message</a><a class="headerlink" href="#transport-wide-rtcp-feedback-message" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">0</span>                   <span class="mi">1</span>                   <span class="mi">2</span>                   <span class="mi">3</span>
 <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">0</span> <span class="mi">1</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="o">|</span><span class="n">V</span><span class="o">=</span><span class="mi">2</span><span class="o">|</span><span class="n">P</span><span class="o">|</span>  <span class="n">FMT</span><span class="o">=</span><span class="mi">15</span> <span class="o">|</span>    <span class="n">PT</span><span class="o">=</span><span class="mi">205</span>     <span class="o">|</span>           <span class="n">length</span>              <span class="o">|</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="o">|</span>                     <span class="n">SSRC</span> <span class="n">of</span> <span class="n">packet</span> <span class="n">sender</span>                     <span class="o">|</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="o">|</span>                      <span class="n">SSRC</span> <span class="n">of</span> <span class="n">media</span> <span class="n">source</span>                     <span class="o">|</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="o">|</span>      <span class="n">base</span> <span class="n">sequence</span> <span class="n">number</span>     <span class="o">|</span>      <span class="n">packet</span> <span class="n">status</span> <span class="n">count</span>      <span class="o">|</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="o">|</span>                 <span class="n">reference</span> <span class="n">time</span>                <span class="o">|</span> <span class="n">fb</span> <span class="n">pkt</span><span class="o">.</span> <span class="n">count</span> <span class="o">|</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="o">|</span>          <span class="n">packet</span> <span class="n">chunk</span>         <span class="o">|</span>         <span class="n">packet</span> <span class="n">chunk</span>          <span class="o">|</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="o">.</span>                                                               <span class="o">.</span>
<span class="o">.</span>                                                               <span class="o">.</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="o">|</span>         <span class="n">packet</span> <span class="n">chunk</span>          <span class="o">|</span>  <span class="n">recv</span> <span class="n">delta</span>   <span class="o">|</span>  <span class="n">recv</span> <span class="n">delta</span>   <span class="o">|</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="o">.</span>                                                               <span class="o">.</span>
<span class="o">.</span>                                                               <span class="o">.</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="o">|</span>           <span class="n">recv</span> <span class="n">delta</span>          <span class="o">|</span>  <span class="n">recv</span> <span class="n">delta</span>   <span class="o">|</span> <span class="n">zero</span> <span class="n">padding</span>  <span class="o">|</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong>version (V)</strong>: 2 bits This field identifies the RTP version.  <strong>- RTP 的版本，当前版本都是 2.</strong></p></li>
<li><p><strong>padding (P)</strong>: 1 bit If set, the padding bit indicates that the packet contains additional padding octets at the end that are not part of the control information but are included in the length field. <strong>- 指示是否有填充内容</strong></p></li>
<li><p><strong>feedback message type (FMT)</strong>: 5 bits This field identifies the type of the FB message. It must have the value 15. ** - 反馈消息类型,  根据RFC4585 的定义，值为 15， 含义是   Application layer FB (AFB) message 应用层反馈消息**</p></li>
<li><p><strong>payload type (PT)</strong>: 8 bits This is the RTCP packet type that identifies the packet as being an RTCP FB message. The value must be RTPFB = 205. <strong>- 荷载类型，根据RFC4585 的定义，值为 205，含义是Transport layer FB message 传输层反馈消息</strong></p></li>
<li><p><strong>SSRC of packet sender</strong>: 32 bits The synchronization source identifier for the originator of this packet. <strong>- 这个反馈消息包发起者的同步源标识</strong></p></li>
<li><p><strong>SSRC of media source</strong>: 32 bits The synchronization source identifier of the media source that this piece of feedback  information is related to. TODO: This is transport wide, do we just  pick any of the media source SSRCs? <strong>- 这个反馈消息包对应的媒体流的同步源标识，这个值待确定，因为这是一个传输通道范围的反馈，这个值必要性不大，可以随意选取一个 media SSRC</strong></p></li>
<li><p><strong>base sequence number</strong>: 16 bits The transport-wide sequence number of the first packet in this feedback. This number is not necessarily increased for every feedback; in the case of reordering it may be decreased.  <strong>- 该 fb 包首个 rtp 包的 transport seq，非 rtp 包序列号。</strong></p></li>
<li><p><strong>packet status count</strong>: 16 bits The number of packets this feedback contains status for, starting with the packet identified by the base  sequence number.    <strong>- 该 fb packet 包含 rtp 包个数。</strong></p></li>
<li><p><strong>reference time</strong>: 24 bits Signed integer indicating an absolute reference time in some (unknown) time base chosen by the sender of  the feedback packets. The value is to be interpreted in multiples of 64ms. The first recv delta in this packet is relative to the reference time. The reference time makes it possible to calculate  the delta between feedbacks even if some feedback packets are lost,  since it always uses the same time base. <strong>- 参考时间，fb 包首个 rtp 的到达时间/64</strong></p></li>
<li><p><strong>feedback packet count</strong>: 8 bits A counter incremented by one for each feedback packet sent. Used to detect feedback packet losses. <strong>-   已发送 feedback 包计数器，可用于 fb packet 丢失检测</strong></p></li>
<li><p><strong>packet chunk</strong>: 16 bits A list of packet status chunks. These indicate  the status of a number of packets starting with the one identified  by base sequence number. See below for details. ** -   描述 rtp 包 4 种状态（见：4.2），有 Run Length Chunk 和 Status Vector Chunk 两种格式**</p></li>
<li><p><strong>recv delta</strong>: 8 bits For each &quot;packet received&quot; status, in the  packet status chunks, a receive delta block will follow. See details   below. <strong>-   当 rtp 包的状态为 Packet received，通过 recv delta 记录其与前一个 rtp 包到达的时间间隔。</strong></p></li>
</ul>
<section id="rtp-packet-status">
<h3><a class="toc-backref" href="#id18">Rtp Packet Status</a><a class="headerlink" href="#rtp-packet-status" title="Permalink to this headline">¶</a></h3>
<p>包的状态 (Packet Status) 表示为 2 个比特的符号：</p>
<ul class="simple">
<li><p>00 Packet not received （包未收到）</p></li>
<li><p>01 Packet received, small delta （包收到，间隔时间很小 ）</p></li>
<li><p>10 Packet received, large or negative delta（ 包收到，间隔时间很大或者为负数）</p></li>
<li><p>11 [Reserved], packet received, w/o recv delta (包收到了，但是没有间隔时间)</p></li>
</ul>
</section>
<section id="packet-chunk">
<h3><a class="toc-backref" href="#id19">Packet chunk</a><a class="headerlink" href="#packet-chunk" title="Permalink to this headline">¶</a></h3>
<p>packet  chunk 对 rtp 的到达状态进行描述，它有两种类型</p>
<ul class="simple">
<li><p>Run Length Chunk</p></li>
<li><p>Status Vector Chunk</p></li>
</ul>
<p>通过第一个比特位标识了是哪种类型</p>
<ul class="simple">
<li><p>0 ：Run Length Chunk</p></li>
<li><p>1 ：Status Vector Chunk</p></li>
</ul>
<section id="run-length-chunk">
<h4><a class="toc-backref" href="#id20">Run Length Chunk</a><a class="headerlink" href="#run-length-chunk" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">0</span>                   <span class="mi">1</span>
 <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="o">|</span><span class="n">T</span><span class="o">|</span> <span class="n">S</span> <span class="o">|</span>       <span class="n">Run</span> <span class="n">Length</span>        <span class="o">|</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
</pre></div>
</div>
<aside class="sidebar">
<p class="sidebar-title">行程编码</p>
<p>编码原理是把数据看成一个线性序列，而这些数据序列组织方式分成两种情况：
1) 连续的重复数据块，
2) 连续的不重复数据块。</p>
<p>对于连续的重复数据快采用的压缩策略是用一个字节（我们称之为数据重数属性）表示数据块重复的次数，然后在这个数据重数属性字节后面存储对应的数据字节本身举个例子：</p>
<p>原始数据：A-A-A-A-A-B-B-C-D</p>
<ul class="simple">
<li><p>压缩前：A-A-A-A-A-B-B-C-D（0x41-0x41-0x41-0x41-0x41-0x42-0x42-0x43-0x44）</p></li>
<li><p>压缩后： 5-A-2-B-1-C-1-D（0x05-0x41-0x02-0x42-0x01-0x43-0x01-0x44）</p></li>
</ul>
</aside>
<p>字段含义如下</p>
<ul class="simple">
<li><p>T (1 bit) : chunk type，当为 Run Length Chunk ，此时值为 0。</p></li>
<li><p>S (1 bit)  ：packet status symbo，2 bits ，表示包的到达状态</p></li>
<li><p>Run Length (13 bit) ：表示多少个连续包的状态</p></li>
</ul>
<p>例 1：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|0 0|0 0 0 0 0 1 1 0 1 1 1 0 1|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

00 代表包未收到 &quot;packet not received&quot; 后面13个比特值为 221，表示221个包未收到
</pre></div>
</div>
<p>例 2:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |0|1 1|0 0 0 0 0 0 0 0 1 1 0 0 0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

11 代表 &quot;packet received, w/o recv delta&quot; ，共有 24 个包，不过没有间隔时间数据
</pre></div>
</div>
</section>
<section id="status-vector-chunk">
<h4><a class="toc-backref" href="#id21">Status Vector Chunk</a><a class="headerlink" href="#status-vector-chunk" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">0</span>                   <span class="mi">1</span>
 <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
<span class="o">|</span><span class="n">T</span><span class="o">|</span><span class="n">S</span><span class="o">|</span>       <span class="n">symbol</span> <span class="nb">list</span>         <span class="o">|</span>
<span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
</pre></div>
</div>
<ul class="simple">
<li><p>T(1 bit): chunk type， 当为 Status Vector Chunk ，此时值为 1。</p></li>
<li><p>S(1 bit): symbol size 符号长度，0 表示符号长度为 14， 1 表示符号长度为 7</p></li>
<li><p>Symbol list(14 bits)，符号表，描述了 x 个包的到达状态，x 的数量取决于 S 的值，
- 当 S = 0 时 x = 14，每个符号为 1 个比特， 0 代表没收到，1 代表收到了
- 当 S = 1 时 x = 7， 每个符号为 2 个比特， 00，01，10，11 表示包的状态</p></li>
</ul>
<p>例 1:</p>
<p>这块数据中 S = 0 ，包含了 14 个包的状态，用 14 个比特位描述， 0 代表没收到，1 代表收到了</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="n">x</span> <span class="s2">&quot;packet not received&quot;</span> <span class="o">-</span> <span class="n">第一个包没收到</span>
<span class="mi">5</span><span class="n">x</span> <span class="s2">&quot;packet received&quot;</span>     <span class="o">-</span> <span class="n">之后</span> <span class="mi">5</span> <span class="n">个包收到了</span>
<span class="mi">3</span><span class="n">x</span> <span class="s2">&quot;packet not received&quot;</span> <span class="o">-</span> <span class="n">之后</span> <span class="mi">3</span> <span class="n">个包没收到</span>
<span class="mi">3</span><span class="n">x</span> <span class="s2">&quot;packet received&quot;</span>     <span class="o">-</span> <span class="n">之后</span> <span class="mi">3</span> <span class="n">个包收到了</span>
<span class="mi">2</span><span class="n">x</span> <span class="s2">&quot;packet not received&quot;</span> <span class="o">-</span> <span class="n">之后</span> <span class="mi">2</span> <span class="n">个包没收到</span>
</pre></div>
</div>
<p>例 2:</p>
<p>这块数据中 S = 1 ，包含了 7 个包的状态，每个包用 2 个比特来描述</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="n">x</span> <span class="s2">&quot;packet not received&quot;</span>

<span class="mi">1</span><span class="n">x</span> <span class="s2">&quot;packet received, w/o timestamp&quot;</span>

<span class="mi">3</span><span class="n">x</span> <span class="s2">&quot;packet received&quot;</span>

<span class="mi">2</span><span class="n">x</span> <span class="s2">&quot;packet not received&quot;</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="receive-delta">
<h2><a class="toc-backref" href="#id22">Receive Delta</a><a class="headerlink" href="#receive-delta" title="Permalink to this headline">¶</a></h2>
<p>Receive Delta 长度为一个字节或两个字节, 记录每个包与之前收到的包的间隔时间, 它是 250us 的倍数
因为 reference_time 是当前包组第一个 packet 到达的时间,, 所以:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="n">st</span> <span class="n">arrive_time</span> <span class="o">=</span> <span class="n">reference_time</span> <span class="o">+</span> <span class="n">receive_delta</span>
<span class="mi">2</span><span class="n">nd</span> <span class="n">arrtive_time</span> <span class="o">=</span> <span class="mi">1</span><span class="n">st</span> <span class="n">arrive_time</span> <span class="o">+</span> <span class="n">receive_delta</span>
</pre></div>
</div>
<p>当包的状态为 Packet received，此时 fb packet 会通过 Receive Delta 记录其与前一个 RTP 包到达时间的间隔，单位是 250us.</p>
<ul class="simple">
<li><p>当状态是 “Packet received, small delta”，用 8-bit unsigned 存储 delta, 附加在 packet status list 之后，
此时 delta 取值为 <cite>[0,255] * 250</cite> , 表示范围为 [0, 63.75] ms.</p></li>
<li><p>当状态是 “Packet received, large or negative delta”，用 16-bit signed 存储 delta，附加在 packet status list 之后, 此时 delta 取值为 <cite>[-32767, 32768] * 250</cite>, 表示范围为 [-8192.0, 8191.75] ms.</p></li>
<li><p>如果间隔时间太大,就需要启用使用新的 RTCP feedback 包了，不过一般也不会有这么大的延迟，除非网络中断了。</p></li>
</ul>
</section>
<section id="id5">
<h2><a class="toc-backref" href="#id23">基于延迟的发送端拥塞控制</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>发送端带宽估计的基本框架和之前版本的接收端的框架类似</p>
<ol class="arabic simple">
<li><p>Pre-filtering: 过滤掉当网络发生中断或一些突发情况</p></li>
<li><p>Arrival-time filter: 采用卡尔曼滤波或趋势线滤波</p></li>
<li><p>Over-use detector: 与预设的阈值进行比较, 检测是否有拥塞</p></li>
<li><p>Rate control : 进行发送速率的调整, 可采用 TCP 中使用的 AIMD(加增乘减法)</p></li>
</ol>
<img alt="../_images/gcc_flow.png" src="../_images/gcc_flow.png" />
<section id="id6">
<h3><a class="toc-backref" href="#id24">基本方法</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>发送端为每个 RTP 包添加 transport wide sequence number 扩展头, 它是一个传输通道范围的序号</p></li>
<li><p>发送端保存这个序号和相应的发送时间 send_time</p></li>
<li><p>接收端记录 RTP 包的到达状态 packet status(是否到达,到达时间),并构造一个 transport wide cc RTCP feedback 消息, 发回给发送方</p></li>
<li><p>发送端将这些 RTP 包的发送时间 send_time, 到达时间 arrive_time 取出来, 并将它们分组(以 5ms 长度)</p></li>
<li><p>发送端计算 group one way delay variant 包组的单向延迟变化</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>g_i: the last packet arriving time of i-th packet group</p></li>
<li><p>G_i: the first packet sending time of i-th packet group</p></li>
<li><p>recv_delta_ms = g_i - g_{i-1}</p></li>
<li><p>send_delta_ms = G_i - G_{i-1}</p></li>
<li><p>delta_ms = recv_delta_ms - send_delta_ms</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="5">
<li><p>计算累计延迟变化</p></li>
</ol>
<div class="math notranslate nohighlight">
\[accumulated\_delay_i = \sum_{j-1}^{i} delta\_ms_{j}\]</div>
<ol class="arabic simple" start="6">
<li><p>将累积延迟变化进行指数平滑 exponential backoff filter</p></li>
</ol>
<div class="math notranslate nohighlight">
\[smoothed\_delay_i = smoothing\_coef * smoothed\_delay_{i-1} + (1 - smoothing\_coef) * accumulated\_delay_i\]</div>
<ol class="arabic simple" start="6">
<li><p>以到达时间为横轴, 延迟变化为纵轴进行线性回归, 计算其拟合出的趋势线的斜率 slope</p></li>
</ol>
<p>x 轴为 arrive_time_ms_i, 并不是第 i 个包组的到达时间, 而是 第 i 个包组最后一个包的到达时间减去第一个包组的最后一个包的到达时间
y 轴为 smoothed_delay_ms_i, 即上而算出的平滑累计延迟变化</p>
<div class="math notranslate nohighlight">
\[slope =  \sum (x_i-x_{avg})(y_i-y_{avg}) / \sum (x_i-x_{avg})^2\]</div>
<ol class="arabic simple" start="7">
<li><p>将计算出来的斜率与一个动态阈值进行比较, 来发现通道是否有拥塞</p></li>
</ol>
<p>每次接收到视频帧 <span class="math notranslate nohighlight">\(t_i\)</span> 时，过度使用检测器都会产生一个信号 s，该信号基于排队延迟梯度 <span class="math notranslate nohighlight">\(m(t_i)\)</span> 和阈值 <span class="math notranslate nohighlight">\(\gamma\)</span> 来驱动 FSM (下面的有限状态机) 的状态 <span class="math notranslate nohighlight">\(\sigma\)</span>，算法 1 详细显示了 s 是如何生成的 ：</p>
<p>当 <span class="math notranslate nohighlight">\(m(t_i) &gt; \gamma\)</span> 时，算法通过增加帧间隔时间 <span class="math notranslate nohighlight">\(\Delta T\)</span> 的变量 <span class="math notranslate nohighlight">\(t_{OU}\)</span> 来跟踪在这种情况下花费的时间。
当 <span class="math notranslate nohighlight">\(t_{OU}\)</span> 达到 <span class="math notranslate nohighlight">\(\bar{t}_{OU}=100ms\)</span> 且 <span class="math notranslate nohighlight">\(m(t_i) &gt; m(t_{i-1})\)</span> 时，产生过度使用信号。</p>
<p>另一方面，如果 <span class="math notranslate nohighlight">\(m(t_i)\)</span> 减小到 <span class="math notranslate nohighlight">\(\gamma\)</span> 以下，则产生未充分利用信号，而当 <span class="math notranslate nohighlight">\(-\gamma \leq m(t_i) \leq \gamma\)</span> 时触发正常信号。</p>
<figure class="align-center" id="id12">
<a class="reference internal image-reference" href="../_images/rate-controller-fsm.gif"><img alt="remote rate controller finite state machine" src="../_images/rate-controller-fsm.gif" style="width: 495.0px; height: 142.20000000000002px;" /></a>
<figcaption>
<p><span class="caption-text">remote rate controller finite state machine</span><a class="headerlink" href="#id12" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<ul class="simple">
<li><p>算法: Over-use Detector pseudo-code 过度使用检测器的伪代码</p></li>
</ul>
<figure class="align-center" id="id13">
<a class="reference internal image-reference" href="../_images/over-use-detector-pseudo-code.gif"><img alt="over-use detector pseudo code" src="../_images/over-use-detector-pseudo-code.gif" style="width: 438.3px; height: 495.0px;" /></a>
<figcaption>
<p><span class="caption-text">over-use detector pseudo code</span><a class="headerlink" href="#id13" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<ol class="arabic simple" start="8">
<li><p>根据以上的检测结果, 调整发送速率, GCC 采用 AIMD 算法</p></li>
</ol>
<p>AIMD 算法来源于 TCP 协议,参见 <a class="reference external" href="https://en.wikipedia.org/wiki/Additive_increase/multiplicative_decrease">https://en.wikipedia.org/wiki/Additive_increase/multiplicative_decrease</a></p>
<p>速率控制分为两部分,</p>
<ol class="arabic simple">
<li><p>根据延迟 delay 来调整带宽估计,或称发送速率</p></li>
<li><p>根据丢包 loss 来调整带宽估计,或称发送速率</p></li>
</ol>
<p>最终会综合比较 <span class="math notranslate nohighlight">\(A_d\)</span> 和 <span class="math notranslate nohighlight">\(A_l\)</span>, 即两者之间的一个最小值此</p>
<ul class="simple">
<li><p>以下为其状态转换图, 空白单元表示维持当前状态</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+----+--------+-----------+------------+--------+</span>
<span class="o">|</span>     \ <span class="n">State</span> <span class="o">|</span>   <span class="n">Hold</span>    <span class="o">|</span>  <span class="n">Increase</span>  <span class="o">|</span><span class="n">Decrease</span><span class="o">|</span>
<span class="o">|</span>      \      <span class="o">|</span>           <span class="o">|</span>            <span class="o">|</span>        <span class="o">|</span>
<span class="o">|</span> <span class="n">Signal</span>\     <span class="o">|</span>           <span class="o">|</span>            <span class="o">|</span>        <span class="o">|</span>
<span class="o">+--------+----+-----------+------------+--------+</span>
<span class="o">|</span>  <span class="n">Over</span><span class="o">-</span><span class="n">use</span>   <span class="o">|</span> <span class="n">Decrease</span>  <span class="o">|</span>  <span class="n">Decrease</span>  <span class="o">|</span>        <span class="o">|</span>
<span class="o">+-------------+-----------+------------+--------+</span>
<span class="o">|</span>  <span class="n">Normal</span>     <span class="o">|</span> <span class="n">Increase</span>  <span class="o">|</span>            <span class="o">|</span>  <span class="n">Hold</span>  <span class="o">|</span>
<span class="o">+-------------+-----------+------------+--------+</span>
<span class="o">|</span>  <span class="n">Under</span><span class="o">-</span><span class="n">use</span>  <span class="o">|</span>           <span class="o">|</span>   <span class="n">Hold</span>     <span class="o">|</span>  <span class="n">Hold</span>  <span class="o">|</span>
<span class="o">+-------------+-----------+------------+--------+</span>
</pre></div>
</div>
</section>
</section>
<section id="id7">
<h2><a class="toc-backref" href="#id25">其他算法细节</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<section id="id8">
<h3><a class="toc-backref" href="#id26">动态阈值的生成</a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>为避免路由队列过小或由于并发的TCP flow 竞争所造成的饥饿, 这个阈值的设置很关键.
阈值如果太小会对于网络的瞬时干扰过于敏感, 如果太大则会反应太迟钝, 很难设置一个合适的值.
GCC v2 采用了一种在 GCC v1 中定义的自适应的阈值  Adaptive threshold</p>
<div class="math notranslate nohighlight">
\[\gamma (t_i) = \gamma(t_{i−1}) + \Delta T · k_\gamma (t_i)(|m(t_i)| − \gamma(t{i−1}))\]</div>
<p>这里的 <span class="math notranslate nohighlight">\(\Delta T\)</span> 是指 <span class="math notranslate nohighlight">\(t_i - t_{i-1}\)</span>, <span class="math notranslate nohighlight">\(t_i\)</span> 是第 i-th 包到达的时间</p>
<p><span class="math notranslate nohighlight">\(\gamma(t_i)\)</span> 代表阈值
<span class="math notranslate nohighlight">\(m(t_i)\)</span> 代表趋势斜率
<span class="math notranslate nohighlight">\(k_\gamma\)</span> 代表阈值调整系数, 定义如下:</p>
<div class="math notranslate nohighlight">
\[\begin{split}k_\gamma (t_i) = \begin{cases}
  &amp; \text{ k_d if } |m(t_i)|  &lt; \gamma (t_{i-1}) \\
  &amp; \text{ k_u if } otherwise
\end{cases}\end{split}\]</div>
<p>在 GCC 草案中 <span class="math notranslate nohighlight">\(k_d\)</span> 取值为 0.00018, <span class="math notranslate nohighlight">\(k_u\)</span> 取值为 0.01</p>
</section>
<section id="id9">
<h3><a class="toc-backref" href="#id27">指数平滑算法和最小二乘法</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>通过对接收和发送的延迟的变化，计算拥塞延迟的变化趋势的斜率 (slope), 用到了指数平滑算法和最小二乘法</p>
<section id="ewma-exponentially-weighted-moving-average">
<h4><a class="toc-backref" href="#id28">EWMA（Exponentially Weighted Moving Average ）</a><a class="headerlink" href="#ewma-exponentially-weighted-moving-average" title="Permalink to this headline">¶</a></h4>
<p>EWMA 指数加权移动平滑法（Exponential Smoothing） 是在移动平均法基础上发展起来的一种时间序列分析预测法.</p>
<p>具体解释参见 <a class="reference external" href="https://www.itl.nist.gov/div898/handbook/pmc/section4/pmc431.htm">https://www.itl.nist.gov/div898/handbook/pmc/section4/pmc431.htm</a></p>
<div class="math notranslate nohighlight">
\[S_t = \alpha y_{t-1} + (1-\alpha)S_{t-1} \,\,\,\,\,\,\, 0 &lt; \alpha \le 1 \,\,\,\,\,\,\, t \ge 3 \, .\]</div>
</section>
<section id="least-squars-method">
<h4><a class="toc-backref" href="#id29">最小二乘法(Least Squars Method)</a><a class="headerlink" href="#least-squars-method" title="Permalink to this headline">¶</a></h4>
<img alt="../_images/lsm.png" src="../_images/lsm.png" />
<div class="math notranslate nohighlight">
\[k = \sum (x_i-x_{avg})(y_i-y_{avg}) / \sum (x_i-x_{avg})^2\]</div>
<p>更多代码分析参见 <a class="reference external" href="../5.code/webrtc_cc.html">GCC 拥塞控制的实现</a></p>
</section>
</section>
</section>
<section id="id11">
<h2><a class="toc-backref" href="#id30">参考资料</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://datatracker.ietf.org/doc/html/draft-holmer-rmcat-transport-wide-cc-extensions-01">RTP Extensions for Transport-wide Congestion Control (draft-holmer-rmcat-transport-wide-cc-extensions-01)</a></p></li>
<li><p><a class="reference external" href="https://datatracker.ietf.org/doc/html/draft-ietf-rmcat-gcc-02">A Google Congestion Control Algorithm for Real-Time Communication</a></p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="webrtc_remb.html" class="btn btn-neutral float-left" title="Google REMB" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="webrtc_cc_evaluation.html" class="btn btn-neutral float-right" title="Congeston Control Evaluation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Walter Fan, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>