<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WebRTC Congestion Control &mdash; webrtc_tutorial 1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="WebRTC Bandwidth Probe" href="webrtc_bw_probe.html" />
    <link rel="prev" title="WebRTC Thread Model" href="webrtc_thread.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> webrtc_tutorial
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../0.tutorial/index.html">0. WebRTC 简明教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1.basic/index.html">1. WebRTC 基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2.transport/index.html">2. WebRTC 传输</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3.media/index.html">3. WebRTC 媒体</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4.practice/index.html">4. WebRTC 实践</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">5. WebRTC 源码分析</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="overview.html">WebRTC 源码概览</a></li>
<li class="toctree-l2"><a class="reference internal" href="build_tools.html">WebRTC 构建工具</a></li>
<li class="toctree-l2"><a class="reference internal" href="build_browser.html">WebRTC 构建浏览器</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_build.html">WebRTC 源码构建</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_test.html">WebRTC test</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_issues.html">WebRTC issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_demux.html">WebRTC Demux</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_thread.html">WebRTC Thread Model</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">WebRTC Congestion Control</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">核心接口</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#receiver-side-congestion-controller">Receiver side congestion controller</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sender-side-congestion-controller">sender side congestion controller</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#config-classes">config classes 配置类</a></li>
<li class="toctree-l3"><a class="reference internal" href="#controller-classes">Controller classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#googleccnetworkcontroller">GoogleCcNetworkController</a></li>
<li class="toctree-l4"><a class="reference internal" href="#delaybasedbwe">DelayBasedBwe</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#estimator-classes">Estimator classes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#trendlineestimator">TrendlineEstimator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#alrdetector">ALRDetector</a></li>
<li class="toctree-l4"><a class="reference internal" href="#congestionwindowpushbackcontroller">CongestionWindowPushbackController</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bitrateestimator">BitrateEstimator</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#unit-tests">unit tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_bw_probe.html">WebRTC Bandwidth Probe</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_pacer.html">WebRTC Pacer</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_sctp.html">WebRTC SCTP library</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_rtp_rtcp_module.html">WebRTC RTP RTCP module</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_rtp_sender.html">WebRTC RTP Sender</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_sdp_offer_answer.html">WebRTC SDP Offer Answer</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_remb_code.html">WebRTC REMB Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_rtx_code.html">WebRTC RTX Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_nack_code.html">WebRTC NACK code</a></li>
<li class="toctree-l2"><a class="reference internal" href="overuse_frame_decoder.html">WebRTC OveruseFrameDetector</a></li>
<li class="toctree-l2"><a class="reference internal" href="remote_bitrate_estimator.html">Remote Bitrate Estimator</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_pc_example.html">WebRTC PeerConnection Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_video_flow.html">WebRTC Video Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_config.html">WebRTC Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="janus_code_1.html">Janus Code analysis 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="aiortc.html">Aiortc library</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6.tool/index.html">5. WebRTC 工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../7.misc/index.html">6. WebRTC 关联技术</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">webrtc_tutorial</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">5. WebRTC 源码分析</a> &raquo;</li>
      <li>WebRTC Congestion Control</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/5.code/webrtc_cc.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="webrtc-congestion-control">
<h1>WebRTC Congestion Control<a class="headerlink" href="#webrtc-congestion-control" title="Permalink to this headline">¶</a></h1>
<table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Abstract</strong></p></td>
<td><p>WebRTC Congestion Control</p></td>
</tr>
<tr class="row-even"><td><p><strong>Authors</strong></p></td>
<td><p>Walter Fan</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Category</strong></p></td>
<td><p>LearningNote</p></td>
</tr>
<tr class="row-even"><td><p><strong>Status</strong></p></td>
<td><p>WIP</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Updated</strong></p></td>
<td><p>2022-10-11</p></td>
</tr>
</tbody>
</table>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#overview" id="id5">Overview</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id6">核心接口</a></p>
<ul>
<li><p><a class="reference internal" href="#receiver-side-congestion-controller" id="id7">Receiver side congestion controller</a></p></li>
<li><p><a class="reference internal" href="#sender-side-congestion-controller" id="id8">sender side congestion controller</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#config-classes" id="id9">config classes 配置类</a></p></li>
<li><p><a class="reference internal" href="#controller-classes" id="id10">Controller classes</a></p>
<ul>
<li><p><a class="reference internal" href="#googleccnetworkcontroller" id="id11">GoogleCcNetworkController</a></p></li>
<li><p><a class="reference internal" href="#delaybasedbwe" id="id12">DelayBasedBwe</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#estimator-classes" id="id13">Estimator classes</a></p>
<ul>
<li><p><a class="reference internal" href="#trendlineestimator" id="id14">TrendlineEstimator</a></p>
<ul>
<li><p><a class="reference internal" href="#code-analysis" id="id15">code analysis</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#alrdetector" id="id16">ALRDetector</a></p></li>
<li><p><a class="reference internal" href="#congestionwindowpushbackcontroller" id="id17">CongestionWindowPushbackController</a></p></li>
<li><p><a class="reference internal" href="#bitrateestimator" id="id18">BitrateEstimator</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#unit-tests" id="id19">unit tests</a></p></li>
<li><p><a class="reference internal" href="#reference" id="id20">Reference</a></p></li>
</ul>
</div>
<section id="overview">
<h2><a class="toc-backref" href="#id5">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>拥塞控制的相关代码在 webrtc 代码的两个模块中</p>
<ul class="simple">
<li><p><a class="reference external" href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/modules/remote_bitrate_estimator">remote_bitrate_estimator</a> 基于 REMB 的旧版本，基本已经废弃了，其中几个类在新版本中也有使用</p></li>
<li><p><a class="reference external" href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/modules/congestion_controller">congestion_controller</a> 基于 Transport Wide CC 的新版本，新旧版本中接收端的估算逻辑移到了发送端，其中的卡尔曼滤波算法也改成了线性回归算法</p></li>
</ul>
<p>发送方从接收方可能会收到以下几种 RTCP 消息</p>
<ul class="simple">
<li><p>RTCP Receiver Report</p></li>
<li><p>RTCP REMB Report</p></li>
<li><p>RTCP Transport Wide CC Feedback</p></li>
</ul>
<p>这样我们可以根据这些 RTCP 消息计算出 RTT, Packet Loss 和 Delay 来估算带宽</p>
<p>估算的比特率有</p>
<p>1) 探测出的带宽
2）实际的吞吐量
3）基于延迟的带宽估算：主要考虑 OWDV, 也会参考 RTT
4）基于丢包的带宽估算</p>
<p>先综合估算一个带宽，再与一个自适应的阈值进行比较，
再决定是否是 Overuser 或者 Underuser
再决定如何增加或减少发送速率 (AIMD)</p>
</section>
<section id="id3">
<h2><a class="toc-backref" href="#id6">核心接口</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NetworkControllerInterface</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">NetworkControllerInterface</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Called when network availabilty changes.  -- 当网络有效或无效时</span>
<span class="w">  </span><span class="n">ABSL_MUST_USE_RESULT</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">NetworkControlUpdate</span><span class="w"> </span><span class="n">OnNetworkAvailability</span><span class="p">(</span><span class="n">NetworkAvailability</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Called when the receiving or sending endpoint changes address.  -- 当网络地址更改时</span>
<span class="w">  </span><span class="n">ABSL_MUST_USE_RESULT</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">NetworkControlUpdate</span><span class="w"> </span><span class="n">OnNetworkRouteChange</span><span class="p">(</span><span class="n">NetworkRouteChange</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Called periodically with a periodicy as specified by</span>
<span class="w">  </span><span class="c1">// NetworkControllerFactoryInterface::GetProcessInterval.  -- 定时回调，以检查网络</span>
<span class="w">  </span><span class="n">ABSL_MUST_USE_RESULT</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">NetworkControlUpdate</span><span class="w"> </span><span class="n">OnProcessInterval</span><span class="p">(</span><span class="w"> </span><span class="n">ProcessInterval</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Called when remotely calculated bitrate is received.    -- 当收到 REMB RTCP 消息时回调</span>
<span class="w">  </span><span class="n">ABSL_MUST_USE_RESULT</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">NetworkControlUpdate</span><span class="w"> </span><span class="n">OnRemoteBitrateReport</span><span class="p">(</span><span class="n">RemoteBitrateReport</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Called round trip time has been calculated by protocol specific mechanisms.  -- 当 RTT 更改时回调（可通过 RTCP RR）</span>
<span class="w">  </span><span class="n">ABSL_MUST_USE_RESULT</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">NetworkControlUpdate</span><span class="w"> </span><span class="n">OnRoundTripTimeUpdate</span><span class="p">(</span><span class="n">RoundTripTimeUpdate</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Called when a packet is sent on the network.  -- 当发出一个 RTP 包时</span>
<span class="w">  </span><span class="n">ABSL_MUST_USE_RESULT</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">NetworkControlUpdate</span><span class="w"> </span><span class="n">OnSentPacket</span><span class="p">(</span><span class="n">SentPacket</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Called when a packet is received from the remote client. -- 当收到一个 RTP 包时</span>
<span class="w">  </span><span class="n">ABSL_MUST_USE_RESULT</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">NetworkControlUpdate</span><span class="w"> </span><span class="n">OnReceivedPacket</span><span class="p">(</span><span class="n">ReceivedPacket</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Called when the stream specific configuration has been updated.  -- 当有流相关的配置更新时</span>
<span class="w">  </span><span class="n">ABSL_MUST_USE_RESULT</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">NetworkControlUpdate</span><span class="w"> </span><span class="n">OnStreamsConfig</span><span class="p">(</span><span class="n">StreamsConfig</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Called when target transfer rate constraints has been changed.  -- 当目标速率约束更改时</span>
<span class="w">  </span><span class="n">ABSL_MUST_USE_RESULT</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">NetworkControlUpdate</span><span class="w"> </span><span class="n">OnTargetRateConstraints</span><span class="p">(</span><span class="n">TargetRateConstraints</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Called when a protocol specific calculation of packet loss has been made.  -- 当收到 TransportLossReport 时</span>
<span class="w">  </span><span class="n">ABSL_MUST_USE_RESULT</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">NetworkControlUpdate</span><span class="w"> </span><span class="n">OnTransportLossReport</span><span class="p">(</span><span class="n">TransportLossReport</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Called with per packet feedback regarding receive time.  -- 当收到 TransportPacketsFeedback 时</span>
<span class="w">  </span><span class="n">ABSL_MUST_USE_RESULT</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">NetworkControlUpdate</span><span class="w"> </span><span class="n">OnTransportPacketsFeedback</span><span class="p">(</span><span class="n">TransportPacketsFeedback</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="c1">// Called with network state estimate updates. -- 当网络状态估计更新时，还在开发中</span>
<span class="w">  </span><span class="n">ABSL_MUST_USE_RESULT</span><span class="w"> </span><span class="k">virtual</span><span class="w"> </span><span class="n">NetworkControlUpdate</span><span class="w"> </span><span class="n">OnNetworkStateEstimate</span><span class="p">(</span><span class="n">NetworkStateEstimate</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>我们比较关心的方法是</p>
<ul class="simple">
<li><p>OnTransportLossReport 传输通道的丢失报告</p></li>
<li><p>OnTransportPacketsFeedback 传输通道的 RTP 包的状态反馈报告</p></li>
</ul>
<section id="receiver-side-congestion-controller">
<h3><a class="toc-backref" href="#id7">Receiver side congestion controller</a><a class="headerlink" href="#receiver-side-congestion-controller" title="Permalink to this headline">¶</a></h3>
<p>兼容旧版本的 REMB 消息，由接收方来指定最大的传输带宽</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rtc_library</span><span class="p">(</span><span class="s2">&quot;congestion_controller&quot;</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">visibility</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;*&quot;</span> <span class="p">]</span>
  <span class="n">configs</span> <span class="o">+=</span> <span class="p">[</span> <span class="s2">&quot;:bwe_test_logging&quot;</span> <span class="p">]</span>
  <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;include/receive_side_congestion_controller.h&quot;</span><span class="p">,</span>
    <span class="s2">&quot;receive_side_congestion_controller.cc&quot;</span><span class="p">,</span>
    <span class="s2">&quot;remb_throttler.cc&quot;</span><span class="p">,</span>
    <span class="s2">&quot;remb_throttler.h&quot;</span><span class="p">,</span>
  <span class="p">]</span>

  <span class="n">deps</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;..:module_api&quot;</span><span class="p">,</span>
    <span class="s2">&quot;../../api/transport:field_trial_based_config&quot;</span><span class="p">,</span>
    <span class="s2">&quot;../../api/transport:network_control&quot;</span><span class="p">,</span>
    <span class="s2">&quot;../../api/units:data_rate&quot;</span><span class="p">,</span>
    <span class="s2">&quot;../../api/units:time_delta&quot;</span><span class="p">,</span>
    <span class="s2">&quot;../../api/units:timestamp&quot;</span><span class="p">,</span>
    <span class="s2">&quot;../../rtc_base/synchronization:mutex&quot;</span><span class="p">,</span>
    <span class="s2">&quot;../pacing&quot;</span><span class="p">,</span>
    <span class="s2">&quot;../remote_bitrate_estimator&quot;</span><span class="p">,</span>
    <span class="s2">&quot;../rtp_rtcp:rtp_rtcp_format&quot;</span><span class="p">,</span>
  <span class="p">]</span>
</pre></div>
</div>
</section>
<section id="sender-side-congestion-controller">
<h3><a class="toc-backref" href="#id8">sender side congestion controller</a><a class="headerlink" href="#sender-side-congestion-controller" title="Permalink to this headline">¶</a></h3>
<p>发送端的拥塞控制逻辑，主要控制类是 GoogleCcNetworkController</p>
<table class="colwidths-given docutils align-default" id="id4">
<caption><span class="caption-text">congestion controller classes</span><a class="headerlink" href="#id4" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Class</p></th>
<th class="head"><p>Responsibility</p></th>
<th class="head"><p>Collablorator</p></th>
<th class="head"><p>Comments</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ProbeController</p></td>
<td><p>探测控制器，通过目标码率判断下次是否探测，探测码率大小</p></td>
<td><p>ProbeControllerConfig</p></td>
<td><p>探测是在开始阶段，及特定的网络状态和条件下触发的</p></td>
</tr>
<tr class="row-odd"><td><p>ProbeBitrateEstimator</p></td>
<td><p>根据feedback计算探测码率</p></td>
<td><p>TBD</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td><p>AcknowledgedBitrateEstimator</p></td>
<td><p>估算当前的吞吐量</p></td>
<td><p>TBD</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td><p>BitrateEstimator</p></td>
<td><p>使用滑动窗口 + 卡尔曼滤波计算当前发送吞吐量</p></td>
<td><p>TBD</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td><p>DelayBasedBwe</p></td>
<td><p>基于延迟预估码率</p></td>
<td><p>TBD</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td><p>TrendlineEstimator</p></td>
<td><p>使用线性回归计算当前网络拥堵情况</p></td>
<td><p>TBD</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td><p>AimdRateControl</p></td>
<td><p>通过TrendLine预测出来的网络状态对码率进行 AIMD(加增乘减)方式调整</p></td>
<td><p>TBD</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td><p>SendSideBandwidthEstimation</p></td>
<td><p>基于丢包计算预估码率，结合延迟预估码率，得到最终的目标码率</p></td>
<td><p>TBD</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-even"><td><p>CongestionWindowPushbackController</p></td>
<td><p>基于当前的rtt设置一个时间窗口，同时基于当前的码率设置当前时间窗口下的数据量，通过判断当前窗口的使用量，如果使用量过大的时候，降低编码时使用的目标码率，加速窗口消退，减少延迟</p></td>
<td><p>TBD</p></td>
<td><p>TBD</p></td>
</tr>
<tr class="row-odd"><td><p>AlrDetector</p></td>
<td><p>应用(码率)受限检测，检测当前的发送码率是否和目标码率由于编码器等原因相差过大受限了，受限情况下会触发带宽预测过程的特殊处理</p></td>
<td><p>TBD</p></td>
<td><p>TBD</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="config-classes">
<h2><a class="toc-backref" href="#id9">config classes 配置类</a><a class="headerlink" href="#config-classes" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>NetworkControllerConfig</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Use StreamsConfig for information about streams that is required for specific</span>
<span class="c1">// adjustments to the algorithms in network controllers. Especially useful</span>
<span class="c1">// for experiments.</span>
<span class="k">struct</span> <span class="nc">StreamsConfig</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">StreamsConfig</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">StreamsConfig</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">StreamsConfig</span><span class="o">&amp;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="o">~</span><span class="n">StreamsConfig</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">Timestamp</span><span class="w"> </span><span class="n">at_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Timestamp</span><span class="o">::</span><span class="n">PlusInfinity</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">requests_alr_probing</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pacing_factor</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// TODO(srte): Use BitrateAllocationLimits here.</span>
<span class="w">   </span><span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">DataRate</span><span class="o">&gt;</span><span class="w"> </span><span class="n">min_total_allocated_bitrate</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">DataRate</span><span class="o">&gt;</span><span class="w"> </span><span class="n">max_padding_rate</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">DataRate</span><span class="o">&gt;</span><span class="w"> </span><span class="n">max_total_allocated_bitrate</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span> <span class="nc">TargetRateConstraints</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">TargetRateConstraints</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">TargetRateConstraints</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TargetRateConstraints</span><span class="o">&amp;</span><span class="p">);</span><span class="w"></span>
<span class="w">   </span><span class="o">~</span><span class="n">TargetRateConstraints</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">Timestamp</span><span class="w"> </span><span class="n">at_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Timestamp</span><span class="o">::</span><span class="n">PlusInfinity</span><span class="p">();</span><span class="w"></span>
<span class="w">   </span><span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">DataRate</span><span class="o">&gt;</span><span class="w"> </span><span class="n">min_data_rate</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">DataRate</span><span class="o">&gt;</span><span class="w"> </span><span class="n">max_data_rate</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="c1">// The initial bandwidth estimate to base target rate on. This should be used</span>
<span class="w">   </span><span class="c1">// as the basis for initial OnTargetTransferRate and OnPacerConfig callbacks.</span>
<span class="w">   </span><span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">DataRate</span><span class="o">&gt;</span><span class="w"> </span><span class="n">starting_rate</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Configuration sent to factory create function. The parameters here are</span>
<span class="c1">// optional to use for a network controller implementation.</span>
<span class="k">struct</span> <span class="nc">NetworkControllerConfig</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="c1">// The initial constraints to start with, these can be changed at any later</span>
<span class="w">   </span><span class="c1">// time by calls to OnTargetRateConstraints. Note that the starting rate</span>
<span class="w">   </span><span class="c1">// has to be set initially to provide a starting state for the network</span>
<span class="w">   </span><span class="c1">// controller, even though the field is marked as optional.</span>
<span class="w">   </span><span class="n">TargetRateConstraints</span><span class="w"> </span><span class="n">constraints</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Initial stream specific configuration, these are changed at any later time</span>
<span class="w">   </span><span class="c1">// by calls to OnStreamsConfig.</span>
<span class="w">   </span><span class="n">StreamsConfig</span><span class="w"> </span><span class="n">stream_based_config</span><span class="p">;</span><span class="w"></span>

<span class="w">   </span><span class="c1">// Optional override of configuration of WebRTC internals. Using nullptr here</span>
<span class="w">   </span><span class="c1">// indicates that the field trial API will be used.</span>
<span class="w">   </span><span class="k">const</span><span class="w"> </span><span class="n">WebRtcKeyValueConfig</span><span class="o">*</span><span class="w"> </span><span class="n">key_value_config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="c1">// Optional override of event log.</span>
<span class="w">   </span><span class="n">RtcEventLog</span><span class="o">*</span><span class="w"> </span><span class="n">event_log</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>GoogCcConfig</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">GoogCcConfig</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">NetworkStateEstimator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">network_state_estimator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">NetworkStatePredictor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">network_state_predictor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w"></span>
<span class="w">   </span><span class="kt">bool</span><span class="w"> </span><span class="n">feedback_only</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="controller-classes">
<h2><a class="toc-backref" href="#id10">Controller classes</a><a class="headerlink" href="#controller-classes" title="Permalink to this headline">¶</a></h2>
<section id="googleccnetworkcontroller">
<h3><a class="toc-backref" href="#id11">GoogleCcNetworkController</a><a class="headerlink" href="#googleccnetworkcontroller" title="Permalink to this headline">¶</a></h3>
<p>It is the first class of congestion controller</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./out/Default/modules_unittests --gtest_filter=&quot;GoogCcNetworkControllerTest.*&quot;
[ RUN      ] GoogCcNetworkControllerTest.InitializeTargetRateOnFirstProcessInterval
[ RUN      ] GoogCcNetworkControllerTest.ReactsToChangedNetworkConditions
[ RUN      ] GoogCcNetworkControllerTest.OnNetworkRouteChanged
[ RUN      ] GoogCcNetworkControllerTest.ProbeOnRouteChange
[ RUN      ] GoogCcNetworkControllerTest.UpdatesDelayBasedEstimate
[ RUN      ] GoogCcNetworkControllerTest.PaceAtMaxOfLowerLinkCapacityAndBwe
</pre></div>
</div>
</section>
<section id="delaybasedbwe">
<h3><a class="toc-backref" href="#id12">DelayBasedBwe</a><a class="headerlink" href="#delaybasedbwe" title="Permalink to this headline">¶</a></h3>
<p>基于延迟的带宽估计模块，主要方法为 <cite>IncomingPacketFeedbackVector</cite>, 其结果为 <cite>DelayBasedBwe::Result</cite></p>
<p>其中根据 OWDV 单向延迟变化 进行趋势估算的类为 TrendlineEstimator</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DelayBasedBwe</span> <span class="p">{</span>
   <span class="n">public</span><span class="p">:</span>
   <span class="n">struct</span> <span class="n">Result</span> <span class="p">{</span>
      <span class="n">Result</span><span class="p">();</span>
      <span class="o">~</span><span class="n">Result</span><span class="p">()</span> <span class="o">=</span> <span class="n">default</span><span class="p">;</span>
      <span class="nb">bool</span> <span class="n">updated</span><span class="p">;</span>
      <span class="nb">bool</span> <span class="n">probe</span><span class="p">;</span>
      <span class="n">DataRate</span> <span class="n">target_bitrate</span> <span class="o">=</span> <span class="n">DataRate</span><span class="p">::</span><span class="n">Zero</span><span class="p">();</span>
      <span class="nb">bool</span> <span class="n">recovered_from_overuse</span><span class="p">;</span>
      <span class="nb">bool</span> <span class="n">backoff_in_alr</span><span class="p">;</span>
   <span class="p">};</span>

   <span class="n">explicit</span> <span class="n">DelayBasedBwe</span><span class="p">(</span><span class="n">const</span> <span class="n">WebRtcKeyValueConfig</span><span class="o">*</span> <span class="n">key_value_config</span><span class="p">,</span>
                           <span class="n">RtcEventLog</span><span class="o">*</span> <span class="n">event_log</span><span class="p">,</span>
                           <span class="n">NetworkStatePredictor</span><span class="o">*</span> <span class="n">network_state_predictor</span><span class="p">);</span>

   <span class="n">DelayBasedBwe</span><span class="p">()</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span>
   <span class="n">DelayBasedBwe</span><span class="p">(</span><span class="n">const</span> <span class="n">DelayBasedBwe</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span>
   <span class="n">DelayBasedBwe</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">const</span> <span class="n">DelayBasedBwe</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="n">delete</span><span class="p">;</span>

   <span class="n">virtual</span> <span class="o">~</span><span class="n">DelayBasedBwe</span><span class="p">();</span>

   <span class="n">Result</span> <span class="n">IncomingPacketFeedbackVector</span><span class="p">(</span>
         <span class="n">const</span> <span class="n">TransportPacketsFeedback</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span>
         <span class="n">absl</span><span class="p">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">DataRate</span><span class="o">&gt;</span> <span class="n">acked_bitrate</span><span class="p">,</span>
         <span class="n">absl</span><span class="p">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">DataRate</span><span class="o">&gt;</span> <span class="n">probe_bitrate</span><span class="p">,</span>
         <span class="n">absl</span><span class="p">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">NetworkStateEstimate</span><span class="o">&gt;</span> <span class="n">network_estimate</span><span class="p">,</span>
         <span class="nb">bool</span> <span class="n">in_alr</span><span class="p">);</span>

   <span class="o">//...</span>


   <span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="estimator-classes">
<h2><a class="toc-backref" href="#id13">Estimator classes</a><a class="headerlink" href="#estimator-classes" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>probe_bitrate_estimator</p></li>
<li><p>acknowledged_bitrate_estimator</p></li>
<li><p>robust_throughput_estimator</p></li>
<li><p>trendline_estimator</p></li>
</ul>
<section id="trendlineestimator">
<h3><a class="toc-backref" href="#id14">TrendlineEstimator</a><a class="headerlink" href="#trendlineestimator" title="Permalink to this headline">¶</a></h3>
<p>以线性回归和最小二乘法计算 OWDV 的趋势，自变量是时间，因变量是 OWDV, 其计算出来的斜率要和设定的阈值进行比较</p>
<section id="code-analysis">
<h4><a class="toc-backref" href="#id15">code analysis</a><a class="headerlink" href="#code-analysis" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Returns the estimated trend k multiplied by some gain.
// 0 &lt; k &lt; 1   -&gt;  the delay increases, queues are filling up
//   k == 0    -&gt;  the delay does not change
//   k &lt; 0     -&gt;  the delay decreases, queues are being emptied
double trendline_slope() const { return trendline_ * threshold_gain_; }

// Update the estimator with a new sample. The deltas should represent deltas
// between timestamp groups as defined by the InterArrival class.
void Update(double recv_delta_ms,
                              double send_delta_ms,
                              int64_t arrival_time_ms) {
  const double delta_ms = recv_delta_ms - send_delta_ms;
  ++num_of_deltas_;
  if (num_of_deltas_ &gt; kDeltaCounterMax)
    num_of_deltas_ = kDeltaCounterMax;
  if (first_arrival_time_ms == -1)
    first_arrival_time_ms = arrival_time_ms;

  // Exponential backoff filter. -- 指数退避滤波器
  accumulated_delay_ += delta_ms;
  BWE_TEST_LOGGING_PLOT(1, &quot;accumulated_delay_ms&quot;, arrival_time_ms,
                        accumulated_delay_);
  smoothed_delay_ = smoothing_coef_ * smoothed_delay_ +
                    (1 - smoothing_coef_) * accumulated_delay_;
  BWE_TEST_LOGGING_PLOT(1, &quot;smoothed_delay_ms&quot;, arrival_time_ms,
                        smoothed_delay_);

  // Simple linear regression. -- 简单线性回归
  delay_hist_.push_back(std::make_pair(
      static_cast&lt;double&gt;(arrival_time_ms - first_arrival_time_ms),
      smoothed_delay_));
  if (delay_hist_.size() &gt; window_size_)
    delay_hist_.pop_front();
  if (delay_hist_.size() == window_size_) {
    // Only update trendline_ if it is possible to fit a line to the data.
    trendline_ = LinearFitSlope(delay_hist_).value_or(trendline_);
  }

  BWE_TEST_LOGGING_PLOT(1, &quot;trendline_slope&quot;, arrival_time_ms, trendline_);
}

//计算线性回归的斜率，传入的是一个列表，其元素是一对数据：
//x 是到达时间 arrival_time_ms: 组内最后一个包的到达时间 - 组内第一个包的到达时间
//y 是 OWDV=recv_delta_ms - send_delta_ms 单向延迟变化: RTP 包组的接收延迟变化 - 发送延迟变化
rtc::Optional&lt;double&gt; LinearFitSlope(
    const std::deque&lt;std::pair&lt;double, double&gt;&gt;&amp; points) {
  RTC_DCHECK(points.size() &gt;= 2);
  // Compute the &quot;center of mass&quot;.
  double sum_x = 0;
  double sum_y = 0;
  for (const auto&amp; point : points) {
    sum_x += point.first;
    sum_y += point.second;
  }
  double x_avg = sum_x / points.size();
  double y_avg = sum_y / points.size();
  // Compute the slope k = \sum (x_i-x_avg)(y_i-y_avg) / \sum (x_i-x_avg)^2
  double numerator = 0;
  double denominator = 0;
  for (const auto&amp; point : points) {
    numerator += (point.first - x_avg) * (point.second - y_avg);
    denominator += (point.first - x_avg) * (point.first - x_avg);
  }
  if (denominator == 0)
    return rtc::Optional&lt;double&gt;();
  return rtc::Optional&lt;double&gt;(numerator / denominator);
}
</pre></div>
</div>
</section>
</section>
<section id="alrdetector">
<h3><a class="toc-backref" href="#id16">ALRDetector</a><a class="headerlink" href="#alrdetector" title="Permalink to this headline">¶</a></h3>
<p>ALR（Application limited region detector）该模块也属于 gcc 的一个子模块</p>
<p>其大概原理就是检查 SentRate/EstimatedRate - 发送速率与估算速率的百分比</p>
<p>当小于 kAlrStartUsagePercent (60%)，认为网络受限，需要启动 probe 重新探测带宽，</p>
<p>当大于 kAlrEndUsagePercent (70%)，认为网络不会恢复了,需要启动下次 probe 探测</p>
</section>
<section id="congestionwindowpushbackcontroller">
<h3><a class="toc-backref" href="#id17">CongestionWindowPushbackController</a><a class="headerlink" href="#congestionwindowpushbackcontroller" title="Permalink to this headline">¶</a></h3>
<p>This class enables pushback from congestion window directly to video encoder.
When the congestion window is filling up, the video encoder target bitrate will be reduced accordingly to accommodate the network changes. To avoid pausing video too frequently, a minimum encoder target bitrate threshold is used to prevent video pause due to a full congestion window.</p>
</section>
<section id="bitrateestimator">
<h3><a class="toc-backref" href="#id18">BitrateEstimator</a><a class="headerlink" href="#bitrateestimator" title="Permalink to this headline">¶</a></h3>
<p>Computes a bayesian estimate of the throughput given acks containing the arrival time and payload size.
Samples which are far from the current estimate or are based on few packets are given a smaller weight, as they are considered to be more likely to have been caused by, e.g., delay spikes unrelated to congestion.</p>
</section>
</section>
<section id="unit-tests">
<h2><a class="toc-backref" href="#id19">unit tests</a><a class="headerlink" href="#unit-tests" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>run unit tests</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">out</span><span class="o">/</span><span class="n">Default</span><span class="o">/</span><span class="n">modules_unittests</span> <span class="o">--</span><span class="n">gtest_filter</span><span class="o">=</span><span class="s2">&quot;GoogCcNetworkControllerTest*&quot;</span>
</pre></div>
</div>
</section>
<section id="reference">
<h2><a class="toc-backref" href="#id20">Reference</a><a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/video/adaptation/encode_usage_resource.h">https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/video/adaptation/encode_usage_resource.h</a></p></li>
<li><p><a class="reference external" href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/video/adaptation/overuse_frame_detector.h">https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/video/adaptation/overuse_frame_detector.h</a></p></li>
<li><p><a class="reference external" href="https://xie.infoq.cn/article/8a8ad2f8170d0072941c2aa9e">Webrtc Rtp/rtcp</a></p></li>
<li><p><a class="reference external" href="https://xie.infoq.cn/article/2f944089023274ef0ac6eabd8">webrtc 即时带宽评估器 BitrateEstimator</a></p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="webrtc_thread.html" class="btn btn-neutral float-left" title="WebRTC Thread Model" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="webrtc_bw_probe.html" class="btn btn-neutral float-right" title="WebRTC Bandwidth Probe" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Walter Fan, Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>